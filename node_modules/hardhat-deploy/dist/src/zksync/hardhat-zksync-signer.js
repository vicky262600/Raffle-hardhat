"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatZksyncSigner = void 0;
const zksync_ethers_1 = require("zksync-ethers");
const utils_1 = require("zksync-ethers/build/utils");
const ethers_1 = require("ethers");
const utils_2 = require("./utils");
const rich_wallets_1 = require("./rich-wallets");
const constants_1 = require("./constants");
const hardhat_zksync_eip712_signer_1 = require("./hardhat-zksync-eip712-signer");
class HardhatZksyncSigner extends zksync_ethers_1.Signer {
    static from(signer, zksyncProvider) {
        const newSigner = super.from(signer, zksyncProvider);
        const hardhatZksyncSigner = Object.setPrototypeOf(newSigner, HardhatZksyncSigner.prototype);
        return hardhatZksyncSigner;
    }
    async sendTransaction(transaction) {
        if (!this.accountWallet) {
            this.accountWallet = await HardhatZksyncSigner._getProperSigner(this.provider, this._address);
        }
        const address = await this.getAddress();
        const from = !transaction.from ? address : ethers_1.ethers.utils.getAddress(transaction.from);
        if (!utils_1.isAddressEq(from, address)) {
            throw new Error('Transaction `from` address mismatch!');
        }
        transaction.from = from;
        if (!this.accountWallet) {
            throw new Error(`Account ${from} is not managed by the node you are connected to.`);
        }
        if (this.accountWallet instanceof zksync_ethers_1.EIP712Signer) {
            return this._sendTransaction(transaction);
        }
        return this.accountWallet.sendTransaction(transaction);
    }
    async signMessage(message) {
        if (!this.accountWallet) {
            this.accountWallet = await HardhatZksyncSigner._getProperSigner(this.provider, this._address);
        }
        if (!this.accountWallet) {
            throw new Error(`Account ${this._address} is not managed by the node you are connected to.`);
        }
        return this.accountWallet.signMessage(message);
    }
    async _signTypedData(domain, types, value) {
        if (!this.accountWallet) {
            this.accountWallet = await HardhatZksyncSigner._getProperSigner(this.provider, this._address);
        }
        if (!this.accountWallet) {
            throw new Error(`Account ${this._address} is not managed by the node you are connected to.`);
        }
        return this.accountWallet._signTypedData(domain, types, value);
    }
    async signTransaction(transaction) {
        if (!this.accountWallet) {
            this.accountWallet = await HardhatZksyncSigner._getProperSigner(this.provider, this._address);
        }
        if (!this.accountWallet) {
            throw new Error(`Account ${this._address} is not managed by the node you are connected to.`);
        }
        const tx = await this._prepareTransaction(transaction);
        return this.accountWallet.signTransaction(tx);
    }
    async _sendTransaction(transaction) {
        const tx = await this._prepareTransaction(transaction);
        tx.customData = tx.customData || {};
        tx.customData.customSignature = await this.accountWallet.sign(transaction);
        const txBytes = utils_1.serialize(tx);
        return await this.provider.sendTransaction(txBytes);
    }
    async _prepareTransaction(transaction) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!transaction.customData && !transaction.type) {
            // use legacy txs by default
            transaction.type = 0;
        }
        if (!transaction.customData && transaction.type !== utils_1.EIP712_TX_TYPE) {
            return (await super.populateTransaction(transaction));
        }
        const address = await this.getAddress();
        (_a = transaction.from) !== null && _a !== void 0 ? _a : (transaction.from = address);
        if (!utils_1.isAddressEq(transaction.from, address)) {
            throw new Error('Transaction `from` address mismatch!');
        }
        transaction.type = utils_1.EIP712_TX_TYPE;
        (_b = transaction.value) !== null && _b !== void 0 ? _b : (transaction.value = 0);
        (_c = transaction.data) !== null && _c !== void 0 ? _c : (transaction.data = '0x');
        (_d = transaction.nonce) !== null && _d !== void 0 ? _d : (transaction.nonce = await this.getNonce());
        transaction.customData = this._fillCustomData((_e = transaction.customData) !== null && _e !== void 0 ? _e : {});
        (_f = transaction.gasPrice) !== null && _f !== void 0 ? _f : (transaction.gasPrice = await this.provider.getGasPrice());
        (_g = transaction.gasLimit) !== null && _g !== void 0 ? _g : (transaction.gasLimit = await this.provider.estimateGas(transaction));
        (_h = transaction.chainId) !== null && _h !== void 0 ? _h : (transaction.chainId = (await this.provider.getNetwork()).chainId);
        return transaction;
    }
    static async _getProperSigner(provider, address) {
        let signer = await utils_2.findWalletFromAddress(address, provider.hardhatNetwork, provider);
        if (!signer && (await utils_2.isImpersonatedSigner(provider, address))) {
            signer = new hardhat_zksync_eip712_signer_1.HardhatZksyncEIP712Signer(new zksync_ethers_1.Wallet(rich_wallets_1.richWallets[constants_1.LOCAL_CHAIN_IDS_ENUM.ERA_NODE][0].privateKey), provider.getNetwork().then((n) => Number(n.chainId)));
        }
        return signer;
    }
}
exports.HardhatZksyncSigner = HardhatZksyncSigner;
//# sourceMappingURL=hardhat-zksync-signer.js.map