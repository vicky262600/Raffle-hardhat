"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isImpersonatedSigner = exports.getRichWalletsIfPossible = exports.getSignerAccounts = exports.findWalletFromAddress = exports.getWalletsFromAccount = exports.isNumber = exports.isString = exports.isHardhatNetworkAccountsConfigStrings = exports.isHardhatNetworkHDAccountsConfig = exports.getWallets = exports.getWallet = void 0;
const zksync_ethers_1 = require("zksync-ethers");
const constants_1 = require("./constants");
const rich_wallets_1 = require("./rich-wallets");
const utils_1 = require("zksync-ethers/build/utils");
async function getWallet(network, provider, privateKeyOrIndex) {
    const privateKey = isString(privateKeyOrIndex) ? privateKeyOrIndex : undefined;
    const accountNumber = isNumber(privateKeyOrIndex) ? privateKeyOrIndex : undefined;
    if (privateKey) {
        return new zksync_ethers_1.Wallet(privateKey, provider);
    }
    const accounts = network.config.accounts;
    const wallets = await getWalletsFromAccount(network, provider, accounts);
    if (accountNumber && accountNumber >= wallets.length) {
        throw new Error('Account private key with specified index is not found');
    }
    if (wallets.length === 0) {
        throw new Error('Accounts are not configured for this network');
    }
    return wallets[accountNumber || 0];
}
exports.getWallet = getWallet;
async function getWallets(network, provider) {
    const accounts = network.config.accounts;
    return await getWalletsFromAccount(network, provider, accounts);
}
exports.getWallets = getWallets;
function isHardhatNetworkHDAccountsConfig(object) {
    return 'mnemonic' in object;
}
exports.isHardhatNetworkHDAccountsConfig = isHardhatNetworkHDAccountsConfig;
function isHardhatNetworkAccountsConfigStrings(object) {
    return typeof object[0] === 'string';
}
exports.isHardhatNetworkAccountsConfigStrings = isHardhatNetworkAccountsConfigStrings;
function isString(object) {
    return typeof object === 'string';
}
exports.isString = isString;
function isNumber(object) {
    return typeof object === 'number';
}
exports.isNumber = isNumber;
async function getWalletsFromAccount(network, provider, accounts) {
    if (!accounts || accounts === 'remote') {
        return await getRichWalletsIfPossible(provider);
    }
    if (isHardhatNetworkAccountsConfigStrings(accounts)) {
        const accountPrivateKeys = accounts;
        const wallets = accountPrivateKeys.map((accountPrivateKey) => new zksync_ethers_1.Wallet(accountPrivateKey, provider));
        return wallets;
    }
    if (isHardhatNetworkHDAccountsConfig(accounts)) {
        const account = accounts;
        const wallet = zksync_ethers_1.Wallet.fromMnemonic(account.mnemonic)
            .connect(provider);
        return [wallet];
    }
    return [];
}
exports.getWalletsFromAccount = getWalletsFromAccount;
async function findWalletFromAddress(address, network, provider, wallets) {
    if (!network) {
        throw new Error('Hardhat network is required to find wallet from address');
    }
    if (!wallets) {
        wallets = await getWallets(network, provider);
    }
    return wallets.find((w) => utils_1.isAddressEq(w.address, address));
}
exports.findWalletFromAddress = findWalletFromAddress;
async function getSignerAccounts(network, provider) {
    const accounts = await network.provider.send('eth_accounts', []);
    if (!accounts || accounts.length === 0) {
        const wallets = await getWallets(network, provider);
        return wallets.map((w) => w.address);
    }
    const allWallets = await getWallets(network, provider);
    return accounts.filter((account) => allWallets.some((wallet) => utils_1.isAddressEq(wallet.address, account)));
}
exports.getSignerAccounts = getSignerAccounts;
async function getRichWalletsIfPossible(provider) {
    const chainId = await provider.send('eth_chainId', []);
    if (constants_1.LOCAL_CHAIN_IDS.includes(chainId)) {
        const chainIdEnum = chainId;
        return rich_wallets_1.richWallets[chainIdEnum].map((wallet) => new zksync_ethers_1.Wallet(wallet.privateKey, provider));
    }
    return [];
}
exports.getRichWalletsIfPossible = getRichWalletsIfPossible;
async function isImpersonatedSigner(provider, address) {
    const chainId = await provider.send('eth_chainId', []);
    if (!constants_1.LOCAL_CHAINS_WITH_IMPERSONATION.includes(chainId)) {
        return false;
    }
    const result = await provider.send('hardhat_stopImpersonatingAccount', [address]);
    if (!result) {
        return false;
    }
    await provider.send('hardhat_impersonateAccount', [address]);
    return true;
}
exports.isImpersonatedSigner = isImpersonatedSigner;
//# sourceMappingURL=utils.js.map